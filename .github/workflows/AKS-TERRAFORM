name: Pipeline Completo EKS (Terraform + Build + Deploy)

on:
  workflow_call:
    inputs:
      # Entradas principais
      environment:
        description: "Ambiente (dev, staging, prod)"
        required: true
        type: string
        default: "dev"
      project-name:
        description: "Nome do projeto"
        required: true
        type: string
        default: "Nexus"
      aws-region:
        description: "AWS Region"
        required: true
        type: string
        default: "us-east-1"
      
      # Configurações Terraform
      terraform-path:
        description: "Caminho do Terraform"
        required: false
        type: string
        default: "terraform/environments/${{ inputs.environment }}"
      terraform-workspace:
        description: "Workspace Terraform (opcional)"
        required: false
        type: string
        default: ""
      terraform-auto-apply:
        description: "Aplicar automaticamente"
        required: false
        type: boolean
        default: true
      
      # Configurações Build
      build-id:
        description: "ID da build"
        required: false
        type: string
        default: ""
      docker-image-name:
        description: "Nome da imagem Docker"
        required: false
        type: string
        default: "demo-app"
      dockerfile-path:
        description: "Path do Dockerfile"
        required: false
        type: string
        default: "Dockerfile"
      context:
        description: "Build context"
        required: false
        type: string
        default: "."
      version-prefix:
        description: "Prefixo de versão"
        required: false
        type: string
        default: "1.0"
      ecr-registry:
        description: "Registry ECR"
        required: false
        type: string
        default: ""
      
      # Configurações Deploy
      k8s-manifest-path:
        description: "Caminho dos manifests Kubernetes"
        required: false
        type: string
        default: "kubernetes"
      k8s-overlay:
        description: "Overlay Kustomize (dev/staging/prod)"
        required: false
        type: string
        default: "${{ inputs.environment }}"
      
      # Controles de execução
      skip-terraform:
        description: "Pular etapa do Terraform"
        required: false
        type: boolean
        default: false
      skip-build:
        description: "Pular etapa do Build"
        required: false
        type: boolean
        default: false
      skip-deploy:
        description: "Pular etapa do Deploy"
        required: false
        type: boolean
        default: false
      deploy-addons:
        description: "Deployar addons (Dashboard, Prometheus, etc)"
        required: false
        type: boolean
        default: true

    outputs:
      # Outputs do Build
      image-version:
        description: "Tag versionada gerada"
        value: ${{ jobs.Pipeline_Completa.outputs.image-version }}
      image-latest:
        description: "Tag latest gerada"
        value: ${{ jobs.Pipeline_Completa.outputs.image-latest }}
      ecr-repository:
        description: "Nome do repositório ECR"
        value: ${{ jobs.Pipeline_Completa.outputs.ecr-repository }}
      # Outputs do Terraform
      cluster-name:
        description: "Nome do cluster EKS"
        value: ${{ jobs.Pipeline_Completa.outputs.cluster-name }}
      cluster-endpoint:
        description: "Endpoint do cluster EKS"
        value: ${{ jobs.Pipeline_Completa.outputs.cluster-endpoint }}

env:
  ENVIRONMENT: ${{ inputs.environment }}
  PROJECT_NAME: ${{ inputs.project-name }}
  AWS_REGION: ${{ inputs.aws-region }}
  ECR_REGISTRY: ${{ inputs.ecr-registry }}

jobs:
  Pipeline_Completa:
    name: Pipeline Completa (Terraform + Build + Deploy)
    runs-on: ubuntu-latest
    env:
      BUILD_NUMBER: ${{ github.run_number }}
      SKIP_TERRAFORM: ${{ inputs.skip-terraform }}
      SKIP_BUILD: ${{ inputs.skip-build }}
      SKIP_DEPLOY: ${{ inputs.skip-deploy }}
      DEPLOY_ADDONS: ${{ inputs.deploy-addons }}
      TF_PATH: ${{ inputs.terraform-path }}
      K8S_MANIFEST_PATH: ${{ inputs.k8s-manifest-path }}
      K8S_OVERLAY: ${{ inputs.k8s-overlay }}

    outputs:
      image-version: ${{ steps.build-meta.outputs.image-version }}
      image-latest: ${{ steps.build-meta.outputs.image-latest }}
      ecr-repository: ${{ steps.ecr-repo.outputs.ecr-repository }}
      cluster-name: ${{ steps.terraform-outputs.outputs.cluster-name }}
      cluster-endpoint: ${{ steps.terraform-outputs.outputs.cluster-endpoint }}

    steps:
      # ============================================
      # 1. CHECKOUT E CONFIGURAÇÃO INICIAL
      # ============================================
      - name: Checkout Código
        uses: actions/checkout@v4

      - name: Configurar AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # ============================================
      # 2. TERRAFORM - INFRAESTRUTURA
      # ============================================
      - name: Setup Terraform
        if: env.SKIP_TERRAFORM == 'false'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '~> 1.9.0'

      - name: Terraform Init
        if: env.SKIP_TERRAFORM == 'false'
        working-directory: ${{ env.TF_PATH }}
        run: |
          terraform init -upgrade -reconfigure
          echo "Terraform inicializado em: ${{ env.TF_PATH }}"

      - name: Terraform Workspace
        if: env.SKIP_TERRAFORM == 'false' && inputs.terraform-workspace != ''
        working-directory: ${{ env.TF_PATH }}
        run: |
          terraform workspace select "${{ inputs.terraform-workspace }}" || \
          terraform workspace new "${{ inputs.terraform-workspace }}"

      - name: Terraform Validate
        if: env.SKIP_TERRAFORM == 'false'
        working-directory: ${{ env.TF_PATH }}
        run: terraform validate -no-color

      - name: Terraform Plan
        if: env.SKIP_TERRAFORM == 'false'
        working-directory: ${{ env.TF_PATH }}
        run: terraform plan -no-color -out=tfplan

      - name: Terraform Apply
        if: env.SKIP_TERRAFORM == 'false' && inputs.terraform-auto-apply
        working-directory: ${{ env.TF_PATH }}
        run: terraform apply -auto-approve tfplan

      - name: Obter Outputs do Terraform
        if: env.SKIP_TERRAFORM == 'false'
        id: terraform-outputs
        working-directory: ${{ env.TF_PATH }}
        run: |
          CLUSTER_NAME=$(terraform output -raw cluster_name)
          CLUSTER_ENDPOINT=$(terraform output -raw cluster_endpoint)
          
          echo "cluster-name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT
          echo "cluster-endpoint=${CLUSTER_ENDPOINT}" >> $GITHUB_OUTPUT
          
          echo "Cluster: ${CLUSTER_NAME}"
          echo "Endpoint: ${CLUSTER_ENDPOINT}"

      # ============================================
      # 3. CONFIGURAR KUBECTL (após Terraform)
      # ============================================
      - name: Configurar kubectl
        if: env.SKIP_TERRAFORM == 'false' && (env.SKIP_BUILD == 'false' || env.SKIP_DEPLOY == 'false')
        run: |
          CLUSTER_NAME="${{ steps.terraform-outputs.outputs.cluster-name || inputs.project-name }}-${{ env.ENVIRONMENT }}"
          
          aws eks update-kubeconfig \
            --name "${CLUSTER_NAME}" \
            --region "${{ env.AWS_REGION }}"
          
          echo "kubectl configurado para cluster: ${CLUSTER_NAME}"
          
          # Verificar conexão
          kubectl cluster-info
          kubectl get nodes

      # ============================================
      # 4. BUILD - CONSTRUIR IMAGEM DOCKER
      # ============================================
      - name: Definir Repositório ECR
        if: env.SKIP_BUILD == 'false'
        id: ecr-repo
        shell: bash
        run: |
          # Usar o registry informado ou criar baseado no account ID
          if [ -z "${{ env.ECR_REGISTRY }}" ]; then
            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            ECR_REGISTRY="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          else
            ECR_REGISTRY="${{ env.ECR_REGISTRY }}"
          fi
          
          ECR_REPO="${{ env.ENVIRONMENT }}/${{ inputs.docker-image-name }}"
          
          echo "ecr-registry=${ECR_REGISTRY}" >> $GITHUB_OUTPUT
          echo "ecr-repository=${ECR_REPO}" >> $GITHUB_OUTPUT
          echo "ECR Registry: ${ECR_REGISTRY}"
          echo "ECR Repository: ${ECR_REPO}"

      - name: Criar Repositório ECR (se necessário)
        if: env.SKIP_BUILD == 'false'
        shell: bash
        run: |
          ECR_REPO="${{ steps.ecr-repo.outputs.ecr-repository }}"
          aws ecr describe-repositories --repository-names "${ECR_REPO}" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "${ECR_REPO}" --image-scanning-configuration scanOnPush=true
          
          echo "Repositório ECR verificado/criado: ${ECR_REPO}"

      - name: Login no Amazon ECR
        if: env.SKIP_BUILD == 'false'
        uses: aws-actions/amazon-ecr-login@v2

      - name: Definir Tags da Imagem
        if: env.SKIP_BUILD == 'false'
        id: build-meta
        shell: bash
        run: |
          VERSION="${{ inputs.version-prefix }}.${{ env.BUILD_NUMBER }}"
          ECR_REGISTRY="${{ steps.ecr-repo.outputs.ecr-registry }}"
          ECR_REPO="${{ steps.ecr-repo.outputs.ecr-repository }}"
          
          IMAGE_VERSION="${ECR_REGISTRY}/${ECR_REPO}:${VERSION}"
          IMAGE_LATEST="${ECR_REGISTRY}/${ECR_REPO}:latest"
          IMAGE_ENV_TAG="${ECR_REGISTRY}/${ECR_REPO}:${{ env.ENVIRONMENT }}"
          
          echo "image-version=${IMAGE_VERSION}" >> $GITHUB_OUTPUT
          echo "image-latest=${IMAGE_LATEST}" >> $GITHUB_OUTPUT
          echo "image-env-tag=${IMAGE_ENV_TAG}" >> $GITHUB_OUTPUT
          
          echo "Imagem Version: ${IMAGE_VERSION}"
          echo "Imagem Latest: ${IMAGE_LATEST}"
          echo "Imagem Env Tag: ${IMAGE_ENV_TAG}"

      - name: Build Docker Image
        if: env.SKIP_BUILD == 'false'
        run: |
          docker build -t "${{ steps.build-meta.outputs.image-version }}" \
            --build-arg ENVIRONMENT="${{ env.ENVIRONMENT }}" \
            --build-arg BUILD_NUMBER="${{ env.BUILD_NUMBER }}" \
            -f "${{ inputs.dockerfile-path }}" "${{ inputs.context }}"
          
          docker tag "${{ steps.build-meta.outputs.image-version }}" "${{ steps.build-meta.outputs.image-latest }}"
          docker tag "${{ steps.build-meta.outputs.image-version }}" "${{ steps.build-meta.outputs.image-env-tag }}"
          
          echo "Imagens construídas e taggeadas"

      - name: Push Docker Image para ECR
        if: env.SKIP_BUILD == 'false'
        run: |
          docker push "${{ steps.build-meta.outputs.image-version }}"
          docker push "${{ steps.build-meta.outputs.image-latest }}"
          docker push "${{ steps.build-meta.outputs.image-env-tag }}"
          
          echo "Imagens pushadas para ECR"

      # ============================================
      # 5. DEPLOY - IMPLANTAR NO EKS
      # ============================================
      - name: Atualizar Manifests com Imagem
        if: env.SKIP_BUILD == 'false' && env.SKIP_DEPLOY == 'false'
        shell: bash
        run: |
          # Atualizar deployment.yaml com a nova imagem
          IMAGE_TAG="${{ steps.build-meta.outputs.image-version }}"
          
          # Para deployments usando kustomize
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/overlays/${{ env.K8S_OVERLAY }}/kustomization.yaml" ]; then
            echo "Atualizando kustomization.yaml com nova imagem..."
            sed -i "s|newTag: .*|newTag: \"${{ inputs.version-prefix }}.${{ env.BUILD_NUMBER }}\"|" \
              "${{ env.K8S_MANIFEST_PATH }}/overlays/${{ env.K8S_OVERLAY }}/kustomization.yaml"
          fi
          
          # Para deployments diretos
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/manifests/deployment.yaml" ]; then
            echo "Atualizando deployment.yaml com nova imagem..."
            sed -i "s|image: .*|image: ${IMAGE_TAG}|" \
              "${{ env.K8S_MANIFEST_PATH }}/manifests/deployment.yaml"
          fi
          
          echo "Manifests atualizados com imagem: ${IMAGE_TAG}"

      - name: Aplicar Manifests Base Kubernetes
        if: env.SKIP_DEPLOY == 'false'
        run: |
          echo "Aplicando manifests base..."
          
          # Aplicar namespace e recursos base
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/base/namespace.yaml" ]; then
            kubectl apply -f "${{ env.K8S_MANIFEST_PATH }}/base/namespace.yaml"
          fi
          
          # Aplicar kustomize base
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/base/kustomization.yaml" ]; then
            kubectl apply -k "${{ env.K8S_MANIFEST_PATH }}/base/"
          fi
          
          echo "Manifests base aplicados"

      - name: Aplicar Overlay do Ambiente
        if: env.SKIP_DEPLOY == 'false'
        run: |
          echo "Aplicando overlay do ambiente: ${{ env.K8S_OVERLAY }}"
          
          OVERLAY_PATH="${{ env.K8S_MANIFEST_PATH }}/overlays/${{ env.K8S_OVERLAY }}"
          
          if [ -f "${OVERLAY_PATH}/kustomization.yaml" ]; then
            kubectl apply -k "${OVERLAY_PATH}/"
            echo "Overlay aplicado via kustomize"
          elif [ -d "${OVERLAY_PATH}" ]; then
            kubectl apply -f "${OVERLAY_PATH}/"
            echo "Manifests do overlay aplicados"
          else
            echo "Overlay não encontrado, pulando..."
          fi

      - name: Deployar Addons (Opcional)
        if: env.SKIP_DEPLOY == 'false' && env.DEPLOY_ADDONS == 'true'
        run: |
          echo "Deployando addons..."
          
          # Kubernetes Dashboard
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/manifests/dashboard/kubernetes-dashboard-values.yaml" ]; then
            echo "Instalando Kubernetes Dashboard..."
            helm upgrade --install kubernetes-dashboard \
              kubernetes-dashboard/kubernetes-dashboard \
              --namespace kubernetes-dashboard \
              --create-namespace \
              --values "${{ env.K8S_MANIFEST_PATH }}/manifests/dashboard/kubernetes-dashboard-values.yaml" \
              --wait
          fi
          
          # Prometheus Stack
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/manifests/monitoring/kube-prometheus-stack-values.yaml" ]; then
            echo "Instalando Prometheus Stack..."
            helm upgrade --install monitoring \
              prometheus-community/kube-prometheus-stack \
              --namespace monitoring \
              --create-namespace \
              --values "${{ env.K8S_MANIFEST_PATH }}/manifests/monitoring/kube-prometheus-stack-values.yaml" \
              --wait
          fi
          
          # Ingress Controller (se configurado)
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/manifests/ingress/nginx-ingress.yaml" ]; then
            echo "Instalando Ingress Controller..."
            kubectl apply -f "${{ env.K8S_MANIFEST_PATH }}/manifests/ingress/nginx-ingress.yaml"
          fi
          
          echo "Addons deployados"

      - name: Health Check e Verificação
        if: env.SKIP_DEPLOY == 'false'
        run: |
          echo "=== HEALTH CHECK DO CLUSTER ==="
          
          # Verificar nodes
          echo "Nodes:"
          kubectl get nodes
          
          # Verificar pods
          echo ""
          echo "Pods (todos os namespaces):"
          kubectl get pods -A
          
          # Verificar serviços
          echo ""
          echo "Services:"
          kubectl get svc -A
          
          # Verificar deployments
          echo ""
          echo "Deployments:"
          kubectl get deployments -A
          
          echo ""
          echo "Health check completado!"

      # ============================================
      # 6. OUTPUT FINAL E RELATÓRIO
      # ============================================
      - name: Gerar Relatório de Deploy
        run: |
          echo "=========================================="
          echo "          DEPLOYMENT COMPLETED            "
          echo "=========================================="
          echo ""
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "Project: ${{ env.PROJECT_NAME }}"
          echo "AWS Region: ${{ env.AWS_REGION }}"
          echo ""
          
          if [ "${{ env.SKIP_TERRAFORM }}" = "false" ]; then
            echo "✅ Terraform: INFRAESTRUTURA APLICADA"
            echo "   Cluster: ${{ steps.terraform-outputs.outputs.cluster-name || 'N/A' }}"
          else
            echo "⏭️  Terraform: SKIPPED"
          fi
          
          if [ "${{ env.SKIP_BUILD }}" = "false" ]; then
            echo "✅ Build: IMAGEM CONSTRUÍDA"
            echo "   Image: ${{ steps.build-meta.outputs.image-version || 'N/A' }}"
          else
            echo "⏭️  Build: SKIPPED"
          fi
          
          if [ "${{ env.SKIP_DEPLOY }}" = "false" ]; then
            echo "✅ Deploy: APLICAÇÃO IMPLANTADA"
            echo "   Kubernetes: Manifests aplicados"
          else
            echo "⏭️  Deploy: SKIPPED"
          fi
          
          echo ""
          echo "=========================================="
