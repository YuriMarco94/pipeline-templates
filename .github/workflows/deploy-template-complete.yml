name: Pipeline Completo EKS (Terraform + Build + Deploy)

on:
  workflow_call:
    inputs:
      # Entradas principais
      environment:
        description: "Ambiente (dev, staging, prod)"
        required: true
        type: string
        default: "dev"
      project-name:
        description: "Nome do projeto"
        required: true
        type: string
        default: "Nexus"
      aws-region:
        description: "AWS Region"
        required: true
        type: string
        default: "us-east-1"
      
      # Configura√ß√µes Terraform
      terraform-path:
        description: "Caminho do Terraform"
        required: false
        type: string
        default: "terraform/environments/${{ inputs.environment }}"
      terraform-workspace:
        description: "Workspace Terraform (opcional)"
        required: false
        type: string
        default: ""
      terraform-auto-apply:
        description: "Aplicar automaticamente"
        required: false
        type: boolean
        default: true
      
      # Configura√ß√µes Build
      build-id:
        description: "ID da build"
        required: false
        type: string
        default: ""
      docker-image-name:
        description: "Nome da imagem Docker"
        required: false
        type: string
        default: "demo-app"
      dockerfile-path:
        description: "Path do Dockerfile"
        required: false
        type: string
        default: "Dockerfile"
      context:
        description: "Build context"
        required: false
        type: string
        default: "."
      version-prefix:
        description: "Prefixo de vers√£o"
        required: false
        type: string
        default: "1.0"
      ecr-registry:
        description: "Registry ECR"
        required: false
        type: string
        default: ""
      
      # Configura√ß√µes Deploy
      k8s-manifest-path:
        description: "Caminho dos manifests Kubernetes"
        required: false
        type: string
        default: "kubernetes"
      k8s-overlay:
        description: "Overlay Kustomize (dev/staging/prod)"
        required: false
        type: string
        default: "${{ inputs.environment }}"
      
      # Controles de execu√ß√£o
      skip-terraform:
        description: "Pular etapa do Terraform"
        required: false
        type: boolean
        default: false
      skip-build:
        description: "Pular etapa do Build"
        required: false
        type: boolean
        default: false
      skip-deploy:
        description: "Pular etapa do Deploy"
        required: false
        type: boolean
        default: false
      deploy-addons:
        description: "Deployar addons (Dashboard, Prometheus, etc)"
        required: false
        type: boolean
        default: true

    outputs:
      # Outputs do Build
      image-version:
        description: "Tag versionada gerada"
        value: ${{ jobs.Pipeline_Completa.outputs.image-version }}
      image-latest:
        description: "Tag latest gerada"
        value: ${{ jobs.Pipeline_Completa.outputs.image-latest }}
      ecr-repository:
        description: "Nome do reposit√≥rio ECR"
        value: ${{ jobs.Pipeline_Completa.outputs.ecr-repository }}
      # Outputs do Terraform
      cluster-name:
        description: "Nome do cluster EKS"
        value: ${{ jobs.Pipeline_Completa.outputs.cluster-name }}
      cluster-endpoint:
        description: "Endpoint do cluster EKS"
        value: ${{ jobs.Pipeline_Completa.outputs.cluster-endpoint }}

env:
  ENVIRONMENT: ${{ inputs.environment }}
  PROJECT_NAME: ${{ inputs.project-name }}
  AWS_REGION: ${{ inputs.aws-region }}
  ECR_REGISTRY: ${{ inputs.ecr-registry }}

jobs:
  Pipeline_Completa:
    name: Pipeline Completa (Terraform + Build + Deploy)
    runs-on: ubuntu-latest
    env:
      BUILD_NUMBER: ${{ github.run_number }}
      SKIP_TERRAFORM: ${{ inputs.skip-terraform }}
      SKIP_BUILD: ${{ inputs.skip-build }}
      SKIP_DEPLOY: ${{ inputs.skip-deploy }}
      DEPLOY_ADDONS: ${{ inputs.deploy-addons }}
      TF_PATH: ${{ inputs.terraform-path }}
      K8S_MANIFEST_PATH: ${{ inputs.k8s-manifest-path }}
      K8S_OVERLAY: ${{ inputs.k8s-overlay }}

    outputs:
      image-version: ${{ steps.build-meta.outputs.image-version }}
      image-latest: ${{ steps.build-meta.outputs.image-latest }}
      ecr-repository: ${{ steps.ecr-repo.outputs.ecr-repository }}
      cluster-name: ${{ steps.terraform-outputs.outputs.cluster-name }}
      cluster-endpoint: ${{ steps.terraform-outputs.outputs.cluster-endpoint }}

    steps:
      # ============================================
      # 1. CHECKOUT E CONFIGURA√á√ÉO INICIAL
      # ============================================
      - name: Checkout C√≥digo
        uses: actions/checkout@v4

      - name: Configurar AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # ============================================
      # 2. TERRAFORM - INFRAESTRUTURA (CORRIGIDO)
      # ============================================
      - name: Setup Terraform
        if: env.SKIP_TERRAFORM == 'false'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '~> 1.9.0'

      - name: Corrigir arquivos Terraform (remove AWS profile)
        if: env.SKIP_TERRAFORM == 'false'
        shell: bash
        run: |
          echo "üîß Corrigindo arquivos Terraform para GitHub Actions..."
          
          # Remove linhas com 'profile = ' de todos os arquivos .tf
          find . -name "*.tf" -type f -exec grep -l "profile\s*=" {} \; | while read file; do
            echo "  Corrigindo: $file"
            # Remove linha com profile = qualquer-coisa
            sed -i '/profile\s*=/d' "$file"
            
            # Adiciona regi√£o se n√£o existir no provider aws
            if grep -q 'provider "aws"' "$file" && ! grep -q 'region\s*=' "$file"; then
              echo "  Adicionando regi√£o ao provider AWS em: $file"
              sed -i '/provider "aws"/a \  region = var.aws_region' "$file"
            fi
          done
          
          echo "‚úÖ Arquivos Terraform corrigidos com sucesso!"

      - name: Terraform Init
        if: env.SKIP_TERRAFORM == 'false'
        working-directory: ${{ env.TF_PATH }}
        run: |
          terraform init -upgrade -reconfigure
          echo "‚úÖ Terraform inicializado em: ${{ env.TF_PATH }}"

      - name: Terraform Workspace
        if: env.SKIP_TERRAFORM == 'false' && inputs.terraform-workspace != ''
        working-directory: ${{ env.TF_PATH }}
        run: |
          terraform workspace select "${{ inputs.terraform-workspace }}" || \
          terraform workspace new "${{ inputs.terraform-workspace }}"

      - name: Terraform Validate
        if: env.SKIP_TERRAFORM == 'false'
        working-directory: ${{ env.TF_PATH }}
        run: terraform validate -no-color

      - name: Terraform Plan
        if: env.SKIP_TERRAFORM == 'false'
        working-directory: ${{ env.TF_PATH }}
        run: terraform plan -no-color -out=tfplan

      - name: Terraform Apply
        if: env.SKIP_TERRAFORM == 'false' && inputs.terraform-auto-apply
        working-directory: ${{ env.TF_PATH }}
        run: terraform apply -auto-approve tfplan

      - name: Obter Outputs do Terraform
        if: env.SKIP_TERRAFORM == 'false'
        id: terraform-outputs
        working-directory: ${{ env.TF_PATH }}
        run: |
          CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}")
          CLUSTER_ENDPOINT=$(terraform output -raw cluster_endpoint 2>/dev/null || echo "")
          
          echo "cluster-name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT
          echo "cluster-endpoint=${CLUSTER_ENDPOINT}" >> $GITHUB_OUTPUT
          
          echo "üìä Outputs do Terraform:"
          echo "  Cluster: ${CLUSTER_NAME}"
          echo "  Endpoint: ${CLUSTER_ENDPOINT}"

      # ============================================
      # 3. CONFIGURAR KUBECTL (ap√≥s Terraform)
      # ============================================
      - name: Configurar kubectl
        if: env.SKIP_TERRAFORM == 'false' && (env.SKIP_BUILD == 'false' || env.SKIP_DEPLOY == 'false')
        run: |
          CLUSTER_NAME="${{ steps.terraform-outputs.outputs.cluster-name || env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}"
          
          echo "üîß Configurando kubectl para cluster: ${CLUSTER_NAME}"
          
          aws eks update-kubeconfig \
            --name "${CLUSTER_NAME}" \
            --region "${{ env.AWS_REGION }}"
          
          echo "‚úÖ kubectl configurado"
          
          # Verificar conex√£o
          echo "üîç Verificando conex√£o com cluster..."
          kubectl cluster-info
          kubectl get nodes

      # ============================================
      # 4. BUILD - CONSTRUIR IMAGEM DOCKER
      # ============================================
      - name: Definir Reposit√≥rio ECR
        if: env.SKIP_BUILD == 'false'
        id: ecr-repo
        shell: bash
        run: |
          echo "üì¶ Configurando reposit√≥rio ECR..."
          
          # Usar o registry informado ou criar baseado no account ID
          if [ -z "${{ env.ECR_REGISTRY }}" ]; then
            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            ECR_REGISTRY="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
            echo "  Registry n√£o informado, usando: ${ECR_REGISTRY}"
          else
            ECR_REGISTRY="${{ env.ECR_REGISTRY }}"
          fi
          
          ECR_REPO="${{ env.ENVIRONMENT }}/${{ inputs.docker-image-name }}"
          
          echo "ecr-registry=${ECR_REGISTRY}" >> $GITHUB_OUTPUT
          echo "ecr-repository=${ECR_REPO}" >> $GITHUB_OUTPUT
          
          echo "‚úÖ ECR Configurado:"
          echo "  Registry: ${ECR_REGISTRY}"
          echo "  Repository: ${ECR_REPO}"

      - name: Criar Reposit√≥rio ECR (se necess√°rio)
        if: env.SKIP_BUILD == 'false'
        shell: bash
        run: |
          ECR_REPO="${{ steps.ecr-repo.outputs.ecr-repository }}"
          
          echo "üîç Verificando reposit√≥rio ECR: ${ECR_REPO}"
          
          if aws ecr describe-repositories --repository-names "${ECR_REPO}" >/dev/null 2>&1; then
            echo "‚úÖ Reposit√≥rio ECR j√° existe"
          else
            echo "üì¶ Criando reposit√≥rio ECR..."
            aws ecr create-repository --repository-name "${ECR_REPO}" --image-scanning-configuration scanOnPush=true
            echo "‚úÖ Reposit√≥rio ECR criado"
          fi

      - name: Login no Amazon ECR
        if: env.SKIP_BUILD == 'false'
        uses: aws-actions/amazon-ecr-login@v2

      - name: Definir Tags da Imagem
        if: env.SKIP_BUILD == 'false'
        id: build-meta
        shell: bash
        run: |
          VERSION="${{ inputs.version-prefix }}.${{ env.BUILD_NUMBER }}"
          ECR_REGISTRY="${{ steps.ecr-repo.outputs.ecr-registry }}"
          ECR_REPO="${{ steps.ecr-repo.outputs.ecr-repository }}"
          
          IMAGE_VERSION="${ECR_REGISTRY}/${ECR_REPO}:${VERSION}"
          IMAGE_LATEST="${ECR_REGISTRY}/${ECR_REPO}:latest"
          IMAGE_ENV_TAG="${ECR_REGISTRY}/${ECR_REPO}:${{ env.ENVIRONMENT }}"
          
          echo "image-version=${IMAGE_VERSION}" >> $GITHUB_OUTPUT
          echo "image-latest=${IMAGE_LATEST}" >> $GITHUB_OUTPUT
          echo "image-env-tag=${IMAGE_ENV_TAG}" >> $GITHUB_OUTPUT
          
          echo "üè∑Ô∏è  Tags da Imagem:"
          echo "  Version: ${IMAGE_VERSION}"
          echo "  Latest: ${IMAGE_LATEST}"
          echo "  Env Tag: ${IMAGE_ENV_TAG}"

      - name: Build Docker Image
        if: env.SKIP_BUILD == 'false'
        run: |
          echo "üî® Construindo imagem Docker..."
          
          docker build -t "${{ steps.build-meta.outputs.image-version }}" \
            --build-arg ENVIRONMENT="${{ env.ENVIRONMENT }}" \
            --build-arg BUILD_NUMBER="${{ env.BUILD_NUMBER }}" \
            -f "${{ inputs.dockerfile-path }}" "${{ inputs.context }}"
          
          docker tag "${{ steps.build-meta.outputs.image-version }}" "${{ steps.build-meta.outputs.image-latest }}"
          docker tag "${{ steps.build-meta.outputs.image-version }}" "${{ steps.build-meta.outputs.image-env-tag }}"
          
          echo "‚úÖ Imagens constru√≠das e taggeadas"

      - name: Push Docker Image para ECR
        if: env.SKIP_BUILD == 'false'
        run: |
          echo "üì§ Enviando imagens para ECR..."
          
          docker push "${{ steps.build-meta.outputs.image-version }}"
          docker push "${{ steps.build-meta.outputs.image-latest }}"
          docker push "${{ steps.build-meta.outputs.image-env-tag }}"
          
          echo "‚úÖ Imagens enviadas para ECR"

      # ============================================
      # 5. DEPLOY - IMPLANTAR NO EKS
      # ============================================
      - name: Atualizar Manifests com Imagem
        if: env.SKIP_BUILD == 'false' && env.SKIP_DEPLOY == 'false'
        shell: bash
        run: |
          echo "üìù Atualizando manifests com nova imagem..."
          
          IMAGE_TAG="${{ steps.build-meta.outputs.image-version }}"
          
          # Para deployments usando kustomize
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/overlays/${{ env.K8S_OVERLAY }}/kustomization.yaml" ]; then        
            echo "  Atualizando kustomization.yaml..."
            sed -i "s|newTag: .*|newTag: \"${{ inputs.version-prefix }}.${{ env.BUILD_NUMBER }}\"|" \
              "${{ env.K8S_MANIFEST_PATH }}/overlays/${{ env.K8S_OVERLAY }}/kustomization.yaml"
          fi
          
          # Para deployments diretos
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/manifests/deployment.yaml" ]; then
            echo "  Atualizando deployment.yaml..."
            sed -i "s|image: .*|image: ${IMAGE_TAG}|" \
              "${{ env.K8S_MANIFEST_PATH }}/manifests/deployment.yaml"
          fi
          
          echo "‚úÖ Manifests atualizados com imagem: ${IMAGE_TAG}"

      - name: Aplicar Manifests Base Kubernetes
        if: env.SKIP_DEPLOY == 'false'
        run: |
          echo "üöÄ Aplicando manifests base Kubernetes..."
          
          # Aplicar namespace e recursos base
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/base/namespace.yaml" ]; then
            kubectl apply -f "${{ env.K8S_MANIFEST_PATH }}/base/namespace.yaml"
          fi
          
          # Aplicar kustomize base
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/base/kustomization.yaml" ]; then
            kubectl apply -k "${{ env.K8S_MANIFEST_PATH }}/base/"
          fi
          
          echo "‚úÖ Manifests base aplicados"

      - name: Aplicar Overlay do Ambiente
        if: env.SKIP_DEPLOY == 'false'
        run: |
          echo "üé® Aplicando overlay do ambiente: ${{ env.K8S_OVERLAY }}"
          
          OVERLAY_PATH="${{ env.K8S_MANIFEST_PATH }}/overlays/${{ env.K8S_OVERLAY }}"
          
          if [ -f "${OVERLAY_PATH}/kustomization.yaml" ]; then
            kubectl apply -k "${OVERLAY_PATH}/"
            echo "‚úÖ Overlay aplicado via kustomize"
          elif [ -d "${OVERLAY_PATH}" ]; then
            kubectl apply -f "${OVERLAY_PATH}/"
            echo "‚úÖ Manifests do overlay aplicados"
          else
            echo "‚ö†Ô∏è  Overlay n√£o encontrado, pulando..."
          fi

      - name: Deployar Addons (Opcional)
        if: env.SKIP_DEPLOY == 'false' && env.DEPLOY_ADDONS == 'true'
        run: |
          echo "üîß Deployando addons..."
          
          # Kubernetes Dashboard
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/manifests/dashboard/kubernetes-dashboard-values.yaml" ]; then      
            echo "  Instalando Kubernetes Dashboard..."
            helm upgrade --install kubernetes-dashboard \
              kubernetes-dashboard/kubernetes-dashboard \
              --namespace kubernetes-dashboard \
              --create-namespace \
              --values "${{ env.K8S_MANIFEST_PATH }}/manifests/dashboard/kubernetes-dashboard-values.yaml" \       
              --wait
            echo "  ‚úÖ Kubernetes Dashboard instalado"
          fi
          
          # Prometheus Stack
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/manifests/monitoring/kube-prometheus-stack-values.yaml" ]; then    
            echo "  Instalando Prometheus Stack..."
            helm upgrade --install monitoring \
              prometheus-community/kube-prometheus-stack \
              --namespace monitoring \
              --create-namespace \
              --values "${{ env.K8S_MANIFEST_PATH }}/manifests/monitoring/kube-prometheus-stack-values.yaml" \     
              --wait
            echo "  ‚úÖ Prometheus Stack instalado"
          fi
          
          echo "‚úÖ Addons deployados"

      - name: Health Check e Verifica√ß√£o
        if: env.SKIP_DEPLOY == 'false'
        run: |
          echo "üè• HEALTH CHECK DO CLUSTER"
          echo "=========================="
          
          # Verificar nodes
          echo ""
          echo "üìä Nodes:"
          kubectl get nodes
          
          # Verificar pods
          echo ""
          echo "üì¶ Pods (todos os namespaces):"
          kubectl get pods -A
          
          # Verificar servi√ßos
          echo ""
          echo "üîå Services:"
          kubectl get svc -A
          
          # Verificar deployments
          echo ""
          echo "üöÄ Deployments:"
          kubectl get deployments -A
          
          echo ""
          echo "‚úÖ Health check completado!"

      # ============================================
      # 6. OUTPUT FINAL E RELAT√ìRIO
      # ============================================
      - name: Gerar Relat√≥rio de Deploy
        run: |
          echo "=========================================="
          echo "          DEPLOYMENT COMPLETED            "
          echo "=========================================="
          echo ""
          echo "üåç Environment: ${{ env.ENVIRONMENT }}"
          echo "üìÅ Project: ${{ env.PROJECT_NAME }}"
          echo "üìç AWS Region: ${{ env.AWS_REGION }}"
          echo "üîÑ Build Number: ${{ env.BUILD_NUMBER }}"
          echo ""
          
          if [ "${{ env.SKIP_TERRAFORM }}" = "false" ]; then
            echo "‚úÖ Terraform: INFRAESTRUTURA APLICADA"
            echo "   Cluster: ${{ steps.terraform-outputs.outputs.cluster-name || 'N/A' }}"
          else
            echo "‚è≠Ô∏è  Terraform: SKIPPED"
          fi
          
          if [ "${{ env.SKIP_BUILD }}" = "false" ]; then
            echo "‚úÖ Build: IMAGEM CONSTRU√çDA"
            echo "   Image: ${{ steps.build-meta.outputs.image-version || 'N/A' }}"
          else
            echo "‚è≠Ô∏è  Build: SKIPPED"
          fi
          
          if [ "${{ env.SKIP_DEPLOY }}" = "false" ]; then
            echo "‚úÖ Deploy: APLICA√á√ÉO IMPLANTADA"
            echo "   Kubernetes: Manifests aplicados"
          else
            echo "‚è≠Ô∏è  Deploy: SKIPPED"
          fi
          
          echo ""
          echo "=========================================="
