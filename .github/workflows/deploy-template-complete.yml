name: Pipeline Completo EKS (Terraform + Build + Deploy)

on:
  workflow_call:
    inputs:
      # Entradas principais
      environment:
        description: "Ambiente (dev, staging, prod)"
        required: true
        type: string
        default: "dev"
      project-name:
        description: "Nome do projeto"
        required: true
        type: string
        default: "Nexus"
      aws-region:
        description: "AWS Region"
        required: true
        type: string
        default: "us-east-1"
      
      # ConfiguraÃ§Ãµes Terraform
      terraform-path:
        description: "Caminho do Terraform"
        required: false
        type: string
        default: "terraform/environments/${{ inputs.environment }}"
      terraform-workspace:
        description: "Workspace Terraform (opcional)"
        required: false
        type: string
        default: ""
      terraform-auto-apply:
        description: "Aplicar automaticamente"
        required: false
        type: boolean
        default: true
      
      # ConfiguraÃ§Ãµes Build
      build-id:
        description: "ID da build"
        required: false
        type: string
        default: ""
      docker-image-name:
        description: "Nome da imagem Docker"
        required: false
        type: string
        default: "demo-app"
      dockerfile-path:
        description: "Path do Dockerfile"
        required: false
        type: string
        default: "Dockerfile"
      context:
        description: "Build context"
        required: false
        type: string
        default: "."
      version-prefix:
        description: "Prefixo de versÃ£o"
        required: false
        type: string
        default: "1.0"
      ecr-registry:
        description: "Registry ECR"
        required: false
        type: string
        default: ""
      
      # ConfiguraÃ§Ãµes Deploy
      k8s-manifest-path:
        description: "Caminho dos manifests Kubernetes"
        required: false
        type: string
        default: "kubernetes"
      k8s-overlay:
        description: "Overlay Kustomize (dev/staging/prod)"
        required: false
        type: string
        default: "${{ inputs.environment }}"
      
      # Controles de execuÃ§Ã£o
      skip-terraform:
        description: "Pular etapa do Terraform"
        required: false
        type: boolean
        default: false
      skip-build:
        description: "Pular etapa do Build"
        required: false
        type: boolean
        default: false
      skip-deploy:
        description: "Pular etapa do Deploy"
        required: false
        type: boolean
        default: false
      deploy-addons:
        description: "Deployar addons (Dashboard, Prometheus, etc)"
        required: false
        type: boolean
        default: true

    outputs:
      # Outputs do Build
      image-version:
        description: "Tag versionada gerada"
        value: ${{ jobs.build.outputs.image-version }}
      image-latest:
        description: "Tag latest gerada"
        value: ${{ jobs.build.outputs.image-latest }}
      ecr-repository:
        description: "Nome do repositÃ³rio ECR"
        value: ${{ jobs.build.outputs.ecr-repository }}
      # Outputs do Terraform
      cluster-name:
        description: "Nome do cluster EKS"
        value: ${{ jobs.terraform.outputs.cluster-name }}
      cluster-endpoint:
        description: "Endpoint do cluster EKS"
        value: ${{ jobs.terraform.outputs.cluster-endpoint }}

env:
  ENVIRONMENT: ${{ inputs.environment }}
  PROJECT_NAME: ${{ inputs.project-name }}
  AWS_REGION: ${{ inputs.aws-region }}
  ECR_REGISTRY: ${{ inputs.ecr-registry }}

jobs:
  # ============================================
  # JOB 1: TERRAFORM - INFRAESTRUTURA
  # ============================================
  terraform:
    if: ${{ !inputs.skip-terraform }}
    name: "ğŸš€ 1. Terraform - Provisionar Infra"
    runs-on: ubuntu-latest
    env:
      TF_PATH: ${{ inputs.terraform-path }}
    
    outputs:
      cluster-name: ${{ steps.terraform-outputs.outputs.cluster-name }}
      cluster-endpoint: ${{ steps.terraform-outputs.outputs.cluster-endpoint }}

    steps:
      - name: ğŸ“¥ Checkout CÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”‘ Configurar AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: âš™ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '~> 1.9.0'

      - name: ğŸ”§ Corrigir arquivos Terraform (remove AWS profile)
        shell: bash
        run: |
          echo "ğŸ”§ Corrigindo arquivos Terraform para GitHub Actions..."
          
          # Remove linhas com 'profile = ' de todos os arquivos .tf
          find . -name "*.tf" -type f -exec grep -l "profile\s*=" {} \; | while read file; do
            echo "  Corrigindo: $file"
            # Remove linha com profile = qualquer-coisa
            sed -i '/profile\s*=/d' "$file"
            
            # Adiciona regiÃ£o se nÃ£o existir no provider aws
            if grep -q 'provider "aws"' "$file" && ! grep -q 'region\s*=' "$file"; then
              echo "  Adicionando regiÃ£o ao provider AWS em: $file"
              sed -i '/provider "aws"/a \  region = var.aws_region' "$file"
            fi
          done
          
          echo "âœ… Arquivos Terraform corrigidos com sucesso!"

      - name: ğŸ“¦ Terraform Init
        working-directory: ${{ env.TF_PATH }}
        run: |
          terraform init -upgrade -reconfigure
          echo "âœ… Terraform inicializado em: ${{ env.TF_PATH }}"

      - name: ğŸ—‚ï¸ Terraform Workspace
        if: ${{ inputs.terraform-workspace != '' }}
        working-directory: ${{ env.TF_PATH }}
        run: |
          terraform workspace select "${{ inputs.terraform-workspace }}" || \
          terraform workspace new "${{ inputs.terraform-workspace }}"

      - name: âœ… Terraform Validate
        working-directory: ${{ env.TF_PATH }}
        run: terraform validate -no-color

      - name: ğŸ“‹ Terraform Plan
        working-directory: ${{ env.TF_PATH }}
        run: terraform plan -no-color -out=tfplan

      - name: ğŸš€ Terraform Apply
        if: ${{ inputs.terraform-auto-apply }}
        working-directory: ${{ env.TF_PATH }}
        run: terraform apply -auto-approve tfplan

      - name: ğŸ“Š Obter Outputs do Terraform
        id: terraform-outputs
        working-directory: ${{ env.TF_PATH }}
        run: |
          CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}")
          CLUSTER_ENDPOINT=$(terraform output -raw cluster_endpoint 2>/dev/null || echo "")
          
          echo "cluster-name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT
          echo "cluster-endpoint=${CLUSTER_ENDPOINT}" >> $GITHUB_OUTPUT
          
          echo "ğŸ“Š Outputs do Terraform:"
          echo "  Cluster: ${CLUSTER_NAME}"
          echo "  Endpoint: ${CLUSTER_ENDPOINT}"

  # ============================================
  # JOB 2: BUILD - CONSTRUIR IMAGEM DOCKER
  # ============================================
  build:
    if: ${{ !inputs.skip-build }}
    name: "ğŸ”¨ 2. Build - Construir Imagem"
    runs-on: ubuntu-latest
    needs: terraform
    env:
      BUILD_NUMBER: ${{ github.run_number }}
      ECR_REGISTRY: ${{ inputs.ecr-registry }}
    
    outputs:
      image-version: ${{ steps.build-meta.outputs.image-version }}
      image-latest: ${{ steps.build-meta.outputs.image-latest }}
      ecr-repository: ${{ steps.ecr-repo.outputs.ecr-repository }}

    steps:
      - name: ğŸ“¥ Checkout CÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”‘ Configurar AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: âš™ï¸ Configurar kubectl (para verificaÃ§Ã£o)
        run: |
          CLUSTER_NAME="${{ needs.terraform.outputs.cluster-name || env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}"
          
          echo "ğŸ”§ Configurando kubectl para cluster: ${CLUSTER_NAME}"
          
          aws eks update-kubeconfig \
            --name "${CLUSTER_NAME}" \
            --region "${{ env.AWS_REGION }}"
          
          echo "âœ… kubectl configurado"
          
          # Verificar conexÃ£o
          echo "ğŸ” Verificando conexÃ£o com cluster..."
          kubectl cluster-info
          kubectl get nodes

      - name: ğŸ“¦ Definir RepositÃ³rio ECR
        id: ecr-repo
        shell: bash
        run: |
          echo "ğŸ“¦ Configurando repositÃ³rio ECR..."
          
          # Usar o registry informado ou criar baseado no account ID
          if [ -z "${{ env.ECR_REGISTRY }}" ]; then
            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            ECR_REGISTRY="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
            echo "  Registry nÃ£o informado, usando: ${ECR_REGISTRY}"
          else
            ECR_REGISTRY="${{ env.ECR_REGISTRY }}"
          fi
          
          ECR_REPO="${{ env.ENVIRONMENT }}/${{ inputs.docker-image-name }}"
          
          echo "ecr-registry=${ECR_REGISTRY}" >> $GITHUB_OUTPUT
          echo "ecr-repository=${ECR_REPO}" >> $GITHUB_OUTPUT
          
          echo "âœ… ECR Configurado:"
          echo "  Registry: ${ECR_REGISTRY}"
          echo "  Repository: ${ECR_REPO}"

      - name: ğŸ—ï¸ Criar RepositÃ³rio ECR (se necessÃ¡rio)
        shell: bash
        run: |
          ECR_REPO="${{ steps.ecr-repo.outputs.ecr-repository }}"
          
          echo "ğŸ” Verificando repositÃ³rio ECR: ${ECR_REPO}"
          
          if aws ecr describe-repositories --repository-names "${ECR_REPO}" >/dev/null 2>&1; then
            echo "âœ… RepositÃ³rio ECR jÃ¡ existe"
          else
            echo "ğŸ“¦ Criando repositÃ³rio ECR..."
            aws ecr create-repository --repository-name "${ECR_REPO}" --image-scanning-configuration scanOnPush=true
            echo "âœ… RepositÃ³rio ECR criado"
          fi

      - name: ğŸ” Login no Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ·ï¸ Definir Tags da Imagem
        id: build-meta
        shell: bash
        run: |
          VERSION="${{ inputs.version-prefix }}.${{ env.BUILD_NUMBER }}"
          ECR_REGISTRY="${{ steps.ecr-repo.outputs.ecr-registry }}"
          ECR_REPO="${{ steps.ecr-repo.outputs.ecr-repository }}"
          
          IMAGE_VERSION="${ECR_REGISTRY}/${ECR_REPO}:${VERSION}"
          IMAGE_LATEST="${ECR_REGISTRY}/${ECR_REPO}:latest"
          IMAGE_ENV_TAG="${ECR_REGISTRY}/${ECR_REPO}:${{ env.ENVIRONMENT }}"
          
          echo "image-version=${IMAGE_VERSION}" >> $GITHUB_OUTPUT
          echo "image-latest=${IMAGE_LATEST}" >> $GITHUB_OUTPUT
          echo "image-env-tag=${IMAGE_ENV_TAG}" >> $GITHUB_OUTPUT
          
          echo "ğŸ·ï¸  Tags da Imagem:"
          echo "  Version: ${IMAGE_VERSION}"
          echo "  Latest: ${IMAGE_LATEST}"
          echo "  Env Tag: ${IMAGE_ENV_TAG}"

      - name: ğŸ³ Build Docker Image
        run: |
          echo "ğŸ”¨ Construindo imagem Docker..."
          
          docker build -t "${{ steps.build-meta.outputs.image-version }}" \
            --build-arg ENVIRONMENT="${{ env.ENVIRONMENT }}" \
            --build-arg BUILD_NUMBER="${{ env.BUILD_NUMBER }}" \
            -f "${{ inputs.dockerfile-path }}" "${{ inputs.context }}"
          
          docker tag "${{ steps.build-meta.outputs.image-version }}" "${{ steps.build-meta.outputs.image-latest }}"
          docker tag "${{ steps.build-meta.outputs.image-version }}" "${{ steps.build-meta.outputs.image-env-tag }}"
          
          echo "âœ… Imagens construÃ­das e taggeadas"

      - name: ğŸ“¤ Push Docker Image para ECR
        run: |
          echo "ğŸ“¤ Enviando imagens para ECR..."
          
          docker push "${{ steps.build-meta.outputs.image-version }}"
          docker push "${{ steps.build-meta.outputs.image-latest }}"
          docker push "${{ steps.build-meta.outputs.image-env-tag }}"
          
          echo "âœ… Imagens enviadas para ECR"

  # ============================================
  # JOB 3: DEPLOY - IMPLANTAR NO EKS
  # ============================================
  deploy:
    if: ${{ !inputs.skip-deploy }}
    name: "ğŸš€ 3. Deploy - Aplicar ao Kubernetes"
    runs-on: ubuntu-latest
    needs: [terraform, build]
    env:
      K8S_MANIFEST_PATH: ${{ inputs.k8s-manifest-path }}
      K8S_OVERLAY: ${{ inputs.k8s-overlay }}
      DEPLOY_ADDONS: ${{ inputs.deploy-addons }}

    steps:
      - name: ğŸ“¥ Checkout CÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”‘ Configurar AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: âš™ï¸ Configurar kubectl
        run: |
          CLUSTER_NAME="${{ needs.terraform.outputs.cluster-name || env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}"
          
          echo "ğŸ”§ Configurando kubectl para cluster: ${CLUSTER_NAME}"
          
          aws eks update-kubeconfig \
            --name "${CLUSTER_NAME}" \
            --region "${{ env.AWS_REGION }}"
          
          echo "âœ… kubectl configurado"
          
          # Verificar conexÃ£o
          echo "ğŸ” Verificando conexÃ£o com cluster..."
          kubectl cluster-info
          kubectl get nodes

      - name: ğŸ“ Atualizar Manifests com Imagem
        shell: bash
        run: |
          echo "ğŸ“ Atualizando manifests com nova imagem..."
          
          IMAGE_TAG="${{ needs.build.outputs.image-version }}"
          
          # Para deployments usando kustomize
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/overlays/${{ env.K8S_OVERLAY }}/kustomization.yaml" ]; then        
            echo "  Atualizando kustomization.yaml..."
            sed -i "s|newTag: .*|newTag: \"${{ inputs.version-prefix }}.${{ github.run_number }}\"|" \
              "${{ env.K8S_MANIFEST_PATH }}/overlays/${{ env.K8S_OVERLAY }}/kustomization.yaml"
          fi
          
          # Para deployments diretos
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/manifests/deployment.yaml" ]; then
            echo "  Atualizando deployment.yaml..."
            sed -i "s|image: .*|image: ${IMAGE_TAG}|" \
              "${{ env.K8S_MANIFEST_PATH }}/manifests/deployment.yaml"
          fi
          
          echo "âœ… Manifests atualizados com imagem: ${IMAGE_TAG}"

      - name: ğŸš€ Aplicar Manifests Base Kubernetes
        run: |
          echo "ğŸš€ Aplicando manifests base Kubernetes..."
          
          # Aplicar namespace e recursos base
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/base/namespace.yaml" ]; then
            kubectl apply -f "${{ env.K8S_MANIFEST_PATH }}/base/namespace.yaml"
          fi
          
          # Aplicar kustomize base
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/base/kustomization.yaml" ]; then
            kubectl apply -k "${{ env.K8S_MANIFEST_PATH }}/base/"
          fi
          
          echo "âœ… Manifests base aplicados"

      - name: ğŸ¨ Aplicar Overlay do Ambiente
        run: |
          echo "ğŸ¨ Aplicando overlay do ambiente: ${{ env.K8S_OVERLAY }}"
          
          OVERLAY_PATH="${{ env.K8S_MANIFEST_PATH }}/overlays/${{ env.K8S_OVERLAY }}"
          
          if [ -f "${OVERLAY_PATH}/kustomization.yaml" ]; then
            kubectl apply -k "${OVERLAY_PATH}/"
            echo "âœ… Overlay aplicado via kustomize"
          elif [ -d "${OVERLAY_PATH}" ]; then
            kubectl apply -f "${OVERLAY_PATH}/"
            echo "âœ… Manifests do overlay aplicados"
          else
            echo "âš ï¸  Overlay nÃ£o encontrado, pulando..."
          fi

      - name: ğŸ”§ Deployar Addons (Opcional)
        if: ${{ env.DEPLOY_ADDONS == 'true' }}
        run: |
          echo "ğŸ”§ Deployando addons..."
          
          # Kubernetes Dashboard
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/manifests/dashboard/kubernetes-dashboard-values.yaml" ]; then      
            echo "  Instalando Kubernetes Dashboard..."
            helm upgrade --install kubernetes-dashboard \
              kubernetes-dashboard/kubernetes-dashboard \
              --namespace kubernetes-dashboard \
              --create-namespace \
              --values "${{ env.K8S_MANIFEST_PATH }}/manifests/dashboard/kubernetes-dashboard-values.yaml" \       
              --wait
            echo "  âœ… Kubernetes Dashboard instalado"
          fi
          
          # Prometheus Stack
          if [ -f "${{ env.K8S_MANIFEST_PATH }}/manifests/monitoring/kube-prometheus-stack-values.yaml" ]; then    
            echo "  Instalando Prometheus Stack..."
            helm upgrade --install monitoring \
              prometheus-community/kube-prometheus-stack \
              --namespace monitoring \
              --create-namespace \
              --values "${{ env.K8S_MANIFEST_PATH }}/manifests/monitoring/kube-prometheus-stack-values.yaml" \     
              --wait
            echo "  âœ… Prometheus Stack instalado"
          fi
          
          echo "âœ… Addons deployados"

      - name: ğŸ¥ Health Check e VerificaÃ§Ã£o
        run: |
          echo "ğŸ¥ HEALTH CHECK DO CLUSTER"
          echo "=========================="
          
          # Verificar nodes
          echo ""
          echo "ğŸ“Š Nodes:"
          kubectl get nodes
          
          # Verificar pods
          echo ""
          echo "ğŸ“¦ Pods (todos os namespaces):"
          kubectl get pods -A
          
          # Verificar serviÃ§os
          echo ""
          echo "ğŸ”Œ Services:"
          kubectl get svc -A
          
          # Verificar deployments
          echo ""
          echo "ğŸš€ Deployments:"
          kubectl get deployments -A
          
          echo ""
          echo "âœ… Health check completado!"

      - name: ğŸ“‹ Gerar RelatÃ³rio de Deploy
        run: |
          echo "=========================================="
          echo "          DEPLOYMENT COMPLETED            "
          echo "=========================================="
          echo ""
          echo "ğŸŒ Environment: ${{ env.ENVIRONMENT }}"
          echo "ğŸ“ Project: ${{ env.PROJECT_NAME }}"
          echo "ğŸ“ AWS Region: ${{ env.AWS_REGION }}"
          echo "ğŸ”„ Build Number: ${{ github.run_number }}"
          echo ""
          echo "âœ… Terraform: INFRAESTRUTURA APLICADA"
          echo "   Cluster: ${{ needs.terraform.outputs.cluster-name || 'N/A' }}"
          echo ""
          echo "âœ… Build: IMAGEM CONSTRUÃDA"
          echo "   Image: ${{ needs.build.outputs.image-version || 'N/A' }}"
          echo ""
          echo "âœ… Deploy: APLICAÃ‡ÃƒO IMPLANTADA"
          echo "   Kubernetes: Manifests aplicados"
          echo ""
          echo "=========================================="
